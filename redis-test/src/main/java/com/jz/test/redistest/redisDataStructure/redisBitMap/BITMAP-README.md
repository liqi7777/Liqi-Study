## 11、用户签到

### 11.1、用户签到-BitMap功能演示 BitMap 数据结构

### github地址：https://github.com/yangxingyue0623/redis-hmdp

> 我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.

> 把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示

> Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。

![签到表 BitMap](https://itsawaysu.oss-cn-shanghai.aliyuncs.com/note/%E7%AD%BE%E5%88%B0%E8%A1%A8%20BitMap.jpg)

BitMap的操作命令有：

* `SETBIT key offset value` 向指定位置 `offset` 存入一个 0 或 1;
* `GETBIT key offset` ：获取指定位置 `offset` 的 Bit 值；
* `BITCOUNT key [start end]` ：统计 BitMap 中值为 1 的 Bit 位的数量；
* `BITFIELD key [GET type offset] `：操作（查询、修改、自增） BitMap 中 Bit 数组中指定位置 `offset` 的值；
    - `type` ：`u` 为无符号，`i` 为有符号；符号后的数字为
* BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回
* BITOP ：将多个BitMap的结果做位运算（与 、或、异或）
* `BITPOS key bit [start] [end]` ：查找 Bit 数组中指定范围内的第一个 0 或 1 出现的位置。

```
        192.168.8.130:6379>setbit bm1 0 1
        (integer)0
        192.168.8.130:6379>setbit bm1 1 1
        (integer)0
        192.168.8.130:6379>setbit bm1 2 1
        (integer)0
        192.168.8.130:6379>setbit bm1 5 1
        (integer)0
        192.168.8.130:6379>setbit bm1 6 1
        (integer)0
        192.168.8.130:6379>setbit bm1 7 1
        (integer)0
        192.168.8.130:6379>getbit bm1 2
        (integer)1
        192.168.8.130:6379>bitcount bm1
        (integer)6
        192.168.8.130:6379>bitfield bm1 get u2 0
        1)(integer)3
        192.168.8.130:6379>bitfield bm1 get u2 0
        1)(integer)3
        192.168.8.130:6379>bitfield bm1 get u3 0
        1)(integer)7
        192.168.8.130:6379>bitfield bm1 get u4 0
        1)(integer)14
        192.168.8.130:6379>
        ut2 0从0开始读两个 1+2=3
```

### 11.2 、用户签到-实现签到功能

需求：实现签到接口，将当前用户当天签到信息保存到Redis中

思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。

> BitMap 底层基于 String 数据结构，因此其操作也都封装到在字符串的相关操作中。

**代码**

**RedisBitMapServiceImpl.sign()**

### 11.3 用户签到-签到统计

**问题1：**什么叫做连续签到天数？ 从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。

Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了

**问题2：**如何得到本月到今天为止的所有签到数据？

> BITFIELD key GET u[dayOfMonth] 0
```text

bitfield bm1 get u2 0是 Redis 中的一个命令，用于对键bm1执行位域操作，具体含义如下：
bitfield：是 Redis 的命令，用于对字符串类型的键进行基于位的复杂操作，它可以将 Redis 字符串看作是一个由二进制位组成的数组，支持对任意偏移量进行访问和修改。
bm1：是要操作的键名，代表 Redis 中存储的一个字符串类型的键。
get：是bitfield命令的一个子操作，表示获取指定位域的值。
u2：表示获取的数据类型为无符号 2 位整数。在 Redis 的位域操作中，u代表无符号整数，后面的数字表示位数。
0：是偏移量，表示从第 0 位开始获取数据。
这个命令的作用就是从键bm1所对应的值的第 0 位开始，获取一个 2 位的无符号整数。例如，如果键bm1对应的值为010110，那么执行bitfield bm1 get u2 0命令将返回1，因为从第 0 位开始的 2 位二进制数01转换为无符号整数就是1。

```

假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。

**问题3：如何从后向前遍历每个bit位？**

注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0
，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。

需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数

有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了

> BitMap 返回的数据是 10 进制的，只需要让得到的 10 进制数字 和 1 进行与运算，每与一次就将签到结果右移一位，实现遍历。

代码:

**RedisBitMapServiceImpl.signCount()**

### 11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案

回顾**缓存穿透**：

发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击

解决方案：

* 判断id<0

* 如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来

第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效

第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据

所以我们如何解决呢？

我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。

现在的问题是这个主键其实并没有那么短，而是很长的一个 主键

哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个

所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间

我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：

id % bitmap.size = 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法，
算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在， 采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。


